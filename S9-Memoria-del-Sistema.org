#+options: H:2
#+latex_class: beamer
#+columns: %45ITEM %10BEAMER_env(Env) %10BEAMER_act(Act) %4BEAMER_col(Col) %8BEAMER_opt(Opt)
#+beamer_theme: default
#+beamer_color_theme:
#+beamer_font_theme:
#+beamer_inner_theme:
#+beamer_outer_theme:
#+beamer_header:

#+title: S9-Memoria-del-Sistema
#+date: 
#+author: Lenin G. Falconí, Richard Dawkins, Richard Tipantiza
#+email: lenin.falconi@epn.edu.ec, richard.dawkins@anotheremail.com, richard.tipantiza@epn.edu.ec
#+language: es
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 27.1 (Org mode 9.3)
#+cite_export: biblatex
# to enable beamer mode M-x org-beamer-mode
#+options: H:2
#+latex_class: beamer
#+columns: %45ITEM %10BEAMER_env(Env) %10BEAMER_act(Act) %4BEAMER_col(Col) %8BEAMER_opt(Opt)
#+beamer_theme: Madrid

#+bibliography: ./bibliography.bib
#+LATEX_HEADER: \nocite{*}
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage[spanish]{babel}
#+LATEX_HEADER: \usepackage[backend=biber,citestyle=apa, style=apa]{biblatex}


* Indicaciones
** Indicaciones
:PROPERTIES:
:BEAMER_opt: allowframebreaks
:END:
** Diseño de las Diapositivas
- Para diseñar sus diapositivas puede consultar cualquiera de las
  presentaciones .ORG desarrolladas por el profesor así como al
  archivo [[https://github.com/LeninGF/EPN-Lectures/blob/main/iccd332ArqComp-2024-B/Tutoriales/Beamer-Emacs/tutorialBeamer.org][tutorialBeamer.org]] en el repositorio de [[https://github.com/LeninGF/EPN-Lectures/blob/main/iccd332ArqComp-2024-B/Tutoriales/Beamer-Emacs/tutorialBeamer.org][GitHub]] de la clase.
- Recuerde que los archivos .ORG son archivos de texto así que los
  puede copiar y sustituir por su texto propio.
** Sobre este Documento
- Este documento tiene la propuesta de temas a tratar y desarrollar
  por los estudiantes.
- Se ha de utilizar como base la bibliografía recomendada, pero puede
  consultar bibliografía adicional.
* Memoria Cache (E2, 11, 162)
** Principios Básicos de las Memorias Caché (E2,11,163)(E2,7,133)
***¿Para que sirve?*** 


El objetivo principal de la memoria caché es mejorar la velocidad de acceso a los datos almacenados, combinando el acceso rápido a datos de una memoria más cara y de alta velocidad (memoria caché) con el almacenamiento más lento pero de mayor capacidad de la memoria principal.


***Funcionamiento***


- La CPU transfiere palabras o bloques entre la caché y la memoria principal. La caché actúa como intermediaria rápida entre la CPU y la memoria principal, almacenando temporalmente datos que la CPU necesita frecuentemente.


** Principios Básicos de las Memorias Caché (E2,11,163)(E2,7,133)

- En el modelo simple de caché (como muestra la Figura 5.1a), la CPU realiza transferencias rápidas a la caché y transferencias más lentas a la memoria principal.

[[./Imagenes/captura1.png]]

** Principios Básicos de las Memorias Caché (E2,11,163)(E2,7,133)

Niveles de Caché: Se organizan en varios niveles (L1, L2, L3). A medida que se avanza en los niveles, la velocidad disminuye, pero la capacidad aumenta.

- Caché de Nivel 1 (L1): La más rápida y de menor capacidad.
- Caché de Nivel 2 (L2): Un poco más lenta, pero con mayor capacidad.
- Caché de Nivel 3 (L3): Menos rápida que L1 y L2, pero aún más rápida que la memoria principal.


*** Elementos de Diseño de la memoria Caché
*** Introducción a la Caché
- "La memoria caché mejora la velocidad de acceso
  al reducir la distancia entre el procesador y la memoria principal."
- "Los fallos de caché generan tráfico en el bus del sistema."
[[./Imagenes/fig4.6.png]]
*** Parámetros de Diseño de la Caché
- "La función de correspondencia, el tamaño de línea y el algoritmo de sustitución
  son clave para el diseño de una caché eficiente."
- "La jerarquía de cachés puede mejorar el rendimiento en aplicaciones bien optimizadas."
 [[./Imagenes/tabla5.1.png]]
 

*** Tamaño Caché
- "El tamaño de la caché impacta directamente en su velocidad y costo."
- "No existe un tamaño 'óptimo' único, ya que depende de la naturaleza de las tareas."
 [[./Imagenes/tabla5.2.png]]

*** Tipos de caché
- "La caché lógica utiliza direcciones virtuales; la física, direcciones físicas."
- "La caché lógica puede ser más rápida pero requiere mayor gestión en cambios de contexto."
  [[./Imagenes/fig5.png]]




** Función de Correspondencia (E2,11,170)(E2,7,137)
:PROPERTIES:
:BEAMER_opt: allowframebreaks
:END:

Se requiere un algoritmo que permita asociar los bloques de memoria principal con las líneas de caché, ya que hay menos líneas de caché que bloques de memoria. Además, es necesario un método para identificar qué bloque de memoria está ocupando una línea específica. Para organizar la caché, se utilizan tres técnicas principales: correspondencia directa, asociativa y asociativa por conjuntos, las cuales serán explicadas junto con ejemplos concretos.
El texto explica tres técnicas para organizar la caché:

 - **Correspondencia directa:** Cada bloque de memoria principal se asigna a una línea de caché específica. Por ejemplo, el bloque 10 se asigna a la línea 10 mod 8 = 2.
   
 - **Correspondencia asociativa:** Cualquier bloque puede ocupar cualquier línea de caché, lo que ofrece más flexibilidad, pero es más lento de buscar.
   
 - **Correspondencia asociativa por conjuntos:** La caché se divide en conjuntos, y cada bloque puede ocupar cualquier línea dentro de un conjunto específico. Por ejemplo, el bloque 10 se asigna al conjunto 10 mod 4 = 2.
   
Estas técnicas optimizan la asignación de memoria y el uso eficiente de la caché.

* Algoritmo de Sustitución
** Algoritmo de Sustitución (E2,7,148)
:PROPERTIES:
:BEAMER_opt: allowframebreaks
:END:
Una vez llena la caché, se debe reemplazar un bloque existente para introducir uno nuevo.
En correspondencia directa, no hay elección, ya que cada bloque tiene una línea específica.
En técnicas asociativas, se requieren algoritmos de sustitución implementados en hardware para alta velocidad.[cite:@stallings2006organización]
1. LRU (Least Recently Used)
2. FIFO (First-In-First-Out
3. LFU (Least Frequently Used
4. Aleatoria

* Política de escritura
** Política de escritura
:PROPERTIES:
:BEAMER_opt: allowframebreaks
:END:
- Casos de reemplazo en caché
  1. Casos de reemplazo en caché
  2. Casos de reemplazo en caché
- Problemas al reemplazar bloques
  1. Acceso múltiple a la memoria principal
  2. Sistemas multiprocesado
- Sistemas multiprocesado
  1. Escritura inmediata
  2. Postescritura
- Estadísticas de escritura
- Vigilancia del bus con escritura inmediata
- Transparencia hardware
- Memoria excluida de caché

* Tamaño de Linea
** Tamaño de Línea
:PROPERTIES:
:BEAMER_opt: allowframebreaks
:END:
- Tamaño de línea de caché:
- Efectos al aumentar el tamaño del bloque:
  1. Reducción de bloques en caché
  2. Mayor distancia de las palabras adicionales:
- Relación compleja entre tamaño y tasa de aciertos
** Número de Cachés (E2, 7, 150)
:PROPERTIES:
:BEAMER_opt: allowframebreaks
:END:

Inicialmente, los sistemas contaban con una sola caché, pero con el tiempo se ha vuelto común utilizar múltiples cachés. Este diseño incluye consideraciones como el número de niveles de caché y el uso de cachés unificadas o separadas. Las cachés separadas evitan la competencia entre instrucciones y datos, mejorando el rendimiento en sistemas avanzados.

**Cachés Multinivel**
Las cachés on-chip, integradas en el procesador, reducen el uso del bus externo y mejoran el rendimiento. Normalmente, se complementan con una caché externa (L2). Los diseños más recientes incluyen múltiples niveles: L1, L2 y, en algunos casos, L3. Estas cachés adicionales, ahora frecuentemente on-chip, mejoran significativamente el rendimiento al reducir los tiempos de acceso a memoria, aunque complican aspectos como tamaño, políticas de escritura y algoritmos de reemplazo.

**Caché Unificada**
Las cachés unificadas almacenan tanto instrucciones como datos en un único espacio, maximizando la tasa de aciertos al adaptarse dinámicamente a las necesidades de ejecución. Además, solo requieren un diseño único, simplificando la implementación.

**Cachés Separadas**
Por otro lado, las cachés separadas para instrucciones y datos son preferidas en sistemas super-escalares y con segmentación de cauce. Este diseño elimina la competencia por recursos entre la ejecución de instrucciones y la unidad de datos, mejorando el rendimiento y optimizando la ejecución paralela de instrucciones.

* Referencias
** Bibliografía
:PROPERTIES:
:BEAMER_opt: allowframebreaks
:END:

#+print_bibliography: 
